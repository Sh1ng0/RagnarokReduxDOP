Base de Datos del Proyecto Helheim
Este documento describe la arquitectura, filosof√≠a y dise√±o de la base de datos para el proyecto Helheim.

‚ú® Filosof√≠a Principal: Modelo H√≠brido (Relacional + JSON)
La base de datos del proyecto adopta un enfoque h√≠brido que combina lo mejor del mundo relacional y el de documentos para alinearse con los principios de la Programaci√≥n Orientada a Datos (DOP) del backend.

La estrategia se basa en dividir la responsabilidad de los datos:

Columnas Relacionales: Se usan para metadatos simples, comunes e indexables. Contienen la informaci√≥n necesaria para filtrar y encontrar registros de forma eficiente (ej: id, category). Son las "etiquetas" de nuestros datos.

Columnas JSON: Se usan para almacenar los datos complejos, semi-estructurados y variables. En esta columna se guarda el record completo de Java serializado. Esto nos da una flexibilidad inmensa, ya que los cambios en el modelo de datos de Java no requieren migraciones en el esquema de la base de datos.

Ventajas de este enfoque:

Flexibilidad M√°xima: Se pueden a√±adir o modificar campos en los records de Java sin necesidad de ejecutar ALTER TABLE.

Alto Rendimiento: Se aprovechan los √≠ndices de las columnas relacionales para b√∫squedas r√°pidas, mientras que la lectura del objeto completo se hace en una sola operaci√≥n, evitando JOINs complejos.

Alineaci√≥n con DOP: El esquema de la base de datos es un reflejo 1:1 de los records inmutables del backend, minimizando la fricci√≥n entre la capa de persistencia y la de l√≥gica.

üõ†Ô∏è Stack Tecnol√≥gico
Base de Datos: MySQL 8.0+ (con soporte nativo para el tipo JSON).

Pool de Conexiones: HikariCP.

Acceso a Datos: jOOQ, para la construcci√≥n de consultas seguras en tiempo de compilaci√≥n (type-safe).

Serializaci√≥n: Jackson, para la conversi√≥n entre records de Java y String JSON.

üó∫Ô∏è Dise√±o de Tablas
Tabla: item_templates
Almacena los "planos" (blueprints) de todos los √≠tems del juego, desde armas y armaduras hasta consumibles y cartas.

Columna	Tipo	Descripci√≥n
id	BIGINT PK	El ID √∫nico del ItemTemplate. Es la clave primaria para b√∫squedas directas.
category	VARCHAR(50)	La categor√≠a principal del √≠tem (EQUIPMENT, CONSUMABLE, etc.). Se usa para filtrar y est√° indexada.
data	JSON	El record completo de Java (WeaponTemplate, ConsumableTemplate, etc.) serializado a JSON.

Exportar a Hojas de c√°lculo
Ejemplo de una fila (Daga):

id: 1201

category: 'EQUIPMENT'

data: {"id": 1201, "name": "Dagger", "type": "DAGGER", "bonuses": {"attack": 15, ...}, ...}

Tablas Futuras (Patr√≥n Id√©ntico)
monster_templates: Seguir√° el mismo patr√≥n. Contendr√° un id relacional y una columna data de tipo JSON con el record del monstruo (stats, loot table, etc.).

actors: Almacenar√° los datos de los personajes ("partidas guardadas"). Usar√° columnas relacionales para datos clave (id, name, level) y columnas JSON para datos complejos como el inventario (CharacterInventories) y el equipo.

üß¨ Flujo de Datos y Herramientas
El ciclo de vida de los datos entre la aplicaci√≥n y la base de datos es el siguiente:

Lectura (Base de Datos ‚Üí Java)
jOOQ construye una consulta SELECT segura en tipos para buscar una fila (ej. WHERE id = ?).

La base de datos devuelve la fila. jOOQ extrae el contenido de la columna data como un String a trav√©s del m√©todo .data().

El c√≥digo del repositorio usa Jackson para deserializar ese String JSON en el record de Java espec√≠fico (WeaponTemplate, ConsumableTemplate, etc.), usando la columna category para decidir a qu√© clase convertirlo.

Escritura (Java ‚Üí Base de Datos)
El c√≥digo de la aplicaci√≥n tiene un record de Java que necesita ser guardado.

Jackson serializa ese record en un String JSON.

jOOQ construye una consulta INSERT o UPDATE segura en tipos, pasando el String JSON como un par√°metro que se guardar√° en la columna data.

‚öôÔ∏è Generaci√≥n de C√≥digo
Para garantizar la seguridad de tipos, se utiliza el generador de c√≥digo de jOOQ a trav√©s de Maven. El comando mvn jooq-codegen:generate se conecta a la base de datos, lee el esquema y crea clases de Java que representan las tablas y columnas, eliminando la posibilidad de errores de tipeo en las consultas SQL.